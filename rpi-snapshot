#!/bin/bash

###############################################################################
#
# rpi-snapshot is Copyright (c) 2019 Alberto Lopez Siemens
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted under the conditions of the BSD LICENSE file at
# the rpi-snapshot github source repository:
#    https://github.com/AlbertoLopSie/rpi-snapshot
#
# Some ideas and code portions borrowed from https://github.com/billw2/rpi-clone
###############################################################################

version=1.0.0

PGM=`basename $0`

rsync_options="--force -rltWDEHXAgoptx"

##################################################
# Verifies we are running as root
##################################################
if [ `id -u` != 0 ]
then
    echo -e "$PGM needs to be run as root.\n"
    exit 1
fi

#########################################################
# Ask for confirmation y returns 0: Yes, 1: No or aborts
#  if 2nd arg is "abort"
#########################################################
confirm()
	{
	if ((unattended || (initialize && Unattended) ))
	then
		return 0
	fi
	printf "\n%s  (yes/no): " "$1"
	read resp
	if [ "$resp" = "y" ] || [ "$resp" = "yes" ]
	then
		return 0
	fi
	if [ "$2" == "abort" ]
	then
		echo -e "Aborting!\n"
		exit 0
	fi
	return 1
	}

##################################################
# Checks all needed utilities are installed or
# ask confirmation to install them
##################################################
commands="rsync parted fdisk findmnt column"
packages="rsync parted util-linux mount bsdmainutils"
need_packages=""

idx=1
for cmd in $commands
do
	if ! command -v $cmd > /dev/null
	then
		pkg=$(echo "$packages" | cut -d " " -f $idx)
		printf "%-30s %s\n" "Command not found: $cmd" "Package required: $pkg"
		need_packages="$need_packages $pkg"
	fi
	((++idx))
done

if [ "$need_packages" != "" ]
then
	confirm "Do you want to apt-get install the packages?" "abort"
	apt-get install -y --no-install-recommends $need_packages
fi


##################################################
# Sets global variables
##################################################
snap=/mnt/snap
snap_log=/var/log/$PGM.log

HOSTNAME=`hostname`

readable()
{
	val=$1
	if [ "$val" == "" ]
	then
		result="   ??"
	else
		blk_size=$2
		val=$((val / 1000 * blk_size))

		if ((val < 1000000))
		then
			result=$(echo $val \
			| awk '{ byte =$1 /1000; printf "%.1f%s", byte, "MB" }')
		elif ((val < 1000000000))
		then
			result=$(echo $val \
			| awk '{ byte =$1 /1000/1000; printf "%.1f%s", byte, "GB" }')
		else
			result=$(echo $val \
			| awk '{ byte =$1 /1000/1000/1000; printf "%.1f%s", byte, "TB" }')
		fi
	fi
	printf -v "${3}" "%s" "$result"
}

qecho()
{
  if ((!quiet))
    then
    echo "$@"
  fi
}

qprintf()
{
  if ((!quiet))
	then
  	printf "$@"
  fi
}

##################################################
# Displays usage help
##################################################
usage()
{
	echo $"
usage: $PGM sdN {-v|--verbose}
         {-u|--unattended} {-q|--quiet}
         {-S|--setup script}
         {-m|--mountdir dir } {-y|--syncdir dir }
         {-x} {-V|--version}

    -v	    - verbose rsync, list all files as they are copied.
    -u	    - unattended clone.  No confirmations asked,
		but abort if disk needs initializing or on error.
    -q      - quiet mode, no output unless errors or initializing. Implies -u.
    -S scr  - Replaces standard setup script rpi-clone-setup with 'scr'
    -e sdX  - edit destination fstab to change booted device names to new
      	        device 'sdX'.  This is Only for fstabs that use device names.
                Used for setting up a USB bootable disk.
    -m dir  - Add dir to a custom list of mounted directories to sync.  Then
                the custom list will be synced instead of the default of all
                mounted directories.  The root directory is always synced.
                Not for when initializing.
    -y dir  - Add dir to a custom list of directories to sync.  Similar to -m
                but dir is sync'ed as part of root (on its mount point) and
                not as a separate partition
    -x      - use set -x for very verbose bash shell script debugging
    -V      - print $PGM version.


  Makes a bootable snapshot of rootfs on another partition

  The idea is to be able to generate a quick snapshot of the active mounted rootfs
  on another boot disk partition and optionally modify cmdline.txt on boot
  partition to reboot later over that image.

  The script modifies the fstab on cloned partition to the new partition structure

    $ sudo $PGM sdg

  Clones can be from a booted SD card or USB disk.  For a description, example
  clone runs and example usage of above options, see the README.md at:

      https://github.com/AlbertoLopSie/rpi-snapshot

  A line logging a $PGM run is written to $snap_log.

  Download:
    git clone hhttps://github.com/AlbertoLopSie/rpi-snapshot
"
  exit 1
}

############################################################
# Hace rsync de $1 a $2 excluyendo los dirs indicados abajo
# si $3 es "with-root-excludes". Caso contrario solo excluye
# .gvfs y lost+found
############################################################
rsync_file_system()
{
	src_dir="$1"
	dst_dir="$2"

	qprintf "  => rsync $1 $2 $3 ..."

  testing=0

  if((!testing))
  then
  	if [ "$3" == "with-root-excludes" ]
  	then
  		rsync $rsync_options --delete \
  			$exclude_swapfile \
  			--exclude '.gvfs' \
  			--exclude '/dev/*' \
  			--exclude '/mnt/snap/*' \
  			--exclude '/proc/*' \
  			--exclude '/run/*' \
  			--exclude '/sys/*' \
  			--exclude '/tmp/*' \
  			--exclude 'lost\+found/*' \
  		$src_dir \
  		$dst_dir
  	else
  		rsync $rsync_options --delete \
  			--exclude '.gvfs' \
  			--exclude 'lost\+found/*' \
  		$src_dir \
  		$dst_dir
  	fi
  fi

  if [ "$rsync_extra_dirs" != "" ] && [ "$1" == "//" ]
  then
    qprintf "\n\nSyncing extra dirs:"
    dirs=$rsync_extra_dirs
    while [ "$dirs" != "" ]
  	do
      if( echo ${dirs} | grep -q "," )
      then
        adir=$(echo "$dirs" | sed -e "s/\(\S*\),\s*\(.*$\)/\1/")
        dirs=$(echo "$dirs" | sed -e "s/\(\S*\),\s*\(.*$\)/\2/")
      else
        adir="$dirs"
        dirs=""
      fi

    qprintf "\n  => rsync $adir/ $dst_dir$adir ..."

    if((!testing))
    then
      rsync $rsync_options --delete \
        $adir/ \
    		$dst_dir$adir
    fi

    done
    qprintf "\n"
  fi
#set +x
	qecho ""
}

############################################################
# Imprime los datos de las particiones seleccionadas
# $src_disk_, $dst_disk_,
############################################################
print_partitions()
{
	if ((quiet)) && ((!initialize))
	then
		return
	fi
	n_parts=$(( (n_src_parts >= n_dst_parts) ? n_src_parts : n_dst_parts ))

	readable $src_disk_size "512" src_size_readable
	readable $dst_disk_size "512" dst_size_readable

	printf "\n%-43s%s" "Booted disk: $src_disk $src_size_readable" #\
#				"                 Destination disk: $dst_disk $dst_size_readable"
# echo $"----------------------------------------------------------------------------------------"
  echo $"
----------------------------------------------------------"
# out=$'Part,   Size,   Used,FS,Label         ,Part, Size,FS,Label\n'
  out=$'Part,   Size,   Used,FS,Label\n'
	for ((p = 1; p <= n_parts; p++))
	do
		if ((p <= n_src_parts && src_exists[p]))
		then
			readable "${src_size_sectors[p]}" "512" tmp
			printf -v sectors_readable "%7s" $tmp

      readable "${src_used_sectors[p]}" "512" tmp
			printf -v used_readable "%7s" $tmp

      if(( src_sync_part[p] ))
      then
        pname="$p ${src_name[p]}"
      else
        pname="  ${src_name[p]}"
      fi

			out=${out}$"$pname,$sectors_readable,$used_readable,${src_fs_type[p]},${src_label[p]},"
		else
			out=${out}$"  ,  ,  ,  ,  ,"
		fi

#		if ((p <= n_dst_parts && dst_exists[p]))
#		then
#			readable ${dst_size_sectors[p]} "512" tmp
#			printf -v sectors_readable "%7s" $tmp
#			out=${out}$"$p,$sectors_readable,${dst_fs_type[p]},${dst_label[p]},"
#		else
#			out=${out}$"  ,  ,  ,  ,"
#		fi

		out=${out}$'\n'
	done

	echo $"$out" | column -t -s ','

	if ((alt_root_part_num > 0))
	then
		echo $"
** Assuming destination root partition for the clone is $dst_part_base$root_part_num
   The root FS mount is not from booted $src_disk.  It is ${src_root_dev#/dev/}"

	fi
#  echo $"
#----------------------------------------------------------------------------------------"
  echo $"----------------------------------------------------------"
}

get_src_disk()
{
  partition=${1#/dev/}
  disk=${partition:: -1}
  num="${partition: -1}"
  if [[ $disk == *"mmcblk"* ]]
  then
  	SD_slot_boot=1
  	disk=${disk:0:7}
  	src_part_base=${disk}p
  fi
  printf -v "${2}" "%s" "$disk"
  printf -v "${3}" "%s" "$num"
}


############################################################
# Obtains info about source partitions
############################################################

src_boot_dev=`findmnt /boot -o source -n`
src_root_dev=`findmnt / -o source -n`
src_part_base=""

boot_part_num=0
alt_root_part_num=0


if [ "$src_boot_dev" == "" ]
then
	get_src_disk "$src_root_dev" "src_disk" "unused"
else
	get_src_disk "$src_boot_dev" "src_disk" "boot_part_num"
fi

get_src_disk "$src_root_dev" "src_root_disk" "root_part_num"

#get_src_disk "$src_root_dev" "src_root_disk" "root_part_num"

if [ "$src_disk" == "" ]
then
	echo "Cannot find booted device."
	exit 1
fi

if [ "$src_part_base" == "" ]
then
	src_part_base=$src_disk
fi

#set -x
src_partition_table=$(parted -m "/dev/$src_disk" unit s print | tr -d ';')
src_fdisk_table=$(fdisk -l /dev/$src_disk | grep "^/dev/")

tmp=$(df | grep -e "^/dev/$src_disk" -e "^/dev/root" -e "$src_root_dev" \
			| tr -s " ")
dev=${src_root_dev#/dev/}
src_df_table=$(echo "$tmp" | sed "s/root/$dev/")

n_src_parts=$(echo "$src_partition_table" | tail -n 1 | cut -d ":" -f 1)
src_disk_size=$(echo "$src_partition_table" \
				| grep "^/dev/$src_disk" | cut -d ":" -f 2 | tr -d 's')

line=$(fdisk -l /dev/$src_disk | grep "Disk identifier:")
src_disk_ID=${line#*x}

src_mount_table=$(findmnt -o source,target -n -l \
				| grep -e "^/dev/$src_disk" -e "^$src_root_dev" | tr -s " ")
n_mounts=$(echo "$src_mount_table" | wc -l)

line=$(echo "$src_fdisk_table" | grep "Extended")
if [ "$line" != "" ]
then
	dev=$(echo "$line" | cut -d " " -f 1)
	ext_part_num="${dev: -1}"
else
	ext_part_num=0
fi

#set -x
for ((p = 1; p <= n_src_parts; p++))
do
	line=$(echo "$src_partition_table" | grep -e "^${p}:")

	if [ "$line" == "" ]
	then
		src_exists[p]=0
		continue
	fi
	src_exists[p]=1

	if ((p == root_part_num))
	then
		src_partition[p]=${src_root_dev#/dev/}
		src_device[p]=$src_root_dev
	else
		src_partition[p]="${src_part_base}${p}"
		src_device[p]="/dev/${src_partition[p]}"
	fi

  dfline=$(echo "$src_df_table" | grep -m 1 "^${src_device[p]} ")
  blocks=$(echo "$dfline" | cut -d " " -f 3)

	# parted sectors are 512 bytes
	src_start_sector[p]=$(echo "$line" | cut -d ":" -f 2 | tr -d 's')
	src_size_sectors[p]=$(echo "$line" | cut -d ":" -f 4 | tr -d 's')
#  src_used_sectors[p]=$(echo "$dfline" | cut -d " " -f 3)
  src_used_sectors[p]=$((blocks * 2))

	part_type=$(echo "$line" | cut -d ":" -f 5)

	src_mounted_dir[p]=$(echo "$src_mount_table" \
						| grep -m 1 -e "^${src_device[p]}" | cut -d " " -f 2)
	if [ "${src_mounted_dir[p]}" != "" ]
	then
		src_sync_part[p]=1
	else
		src_sync_part[p]=0
	fi

	src_name[p]=""
	if [ "$part_type" != "" ]
	then
		src_fs_type[p]="$part_type"
	else
		src_fs_type[p]="--"
	fi
	src_label[p]="--"

	if [ "${src_mounted_dir[p]}" == "/" ]
	then
		src_name[p]="root"
	#
	# If root on device other than booted SD card, root_part_num assumed to be
	# booted /boot part_num + 1 and alt_root_part_num  is from root device.
	#
	elif ((p == root_part_num)) && ((alt_root_part_num > 0))
	then
		src_name[p]="root**"
	elif ((p == ext_part_num))
	then
		src_fs_type[p]="EXT"
	elif [[ "$part_type" == *"linux-swap"* ]]
	then
		src_fs_type[p]="swap"
	elif [ "${src_mounted_dir[p]}" != "" ]
	then
		src_name[p]="${src_mounted_dir[p]}"
	fi

	if [[ "$part_type" == *"ext"* ]]
	then
		label=`e2label ${src_device[p]} 2> /dev/null`
		if [ "$label" != "" ]
		then
			src_label[p]="$label"
		fi
	fi
  set +x
done

############################################################
# Procesa la linea de comandos
############################################################

# command line
#
setup_args=""
edit_fstab_name=""
ext_label=""
verbose="no"

force_initialize=0
force_2_parts=0
force_sync=0
all_sync=0
usage_error=0
unattended=0
Unattended=0
quiet=0
custom_sync=0
leave_sd_usb_boot=0
convert_to_partuuid=0

rsync_extra_dirs=""

#set -x
while [ "$1" ]
do
	case "$1" in
		-v|--verbose)
			verbose="yes"
			rsync_options=${rsync_options}v
			;;
		-u|--unattended)
			unattended=1
			;;
		-U|--Unattended-init)
			unattended=1
			Unattended=1
			;;
		-q|--quiet)
			unattended=1
			quiet=1
			rsync_options=${rsync_options}q
			;;
		-s|--setup)
			shift
			if ! command -v $setup_command > /dev/null
			then
				echo "Cannot find script $setup_command for setup arg \"$1\"."
				usage_error=1
			fi
			if [ "$setup_args" == "" ]
			then
				setup_args="$1"
			else
				setup_args="$setup_args $1"
			fi
			;;
    -S|--script)
      shift
      if ! command -v $1 > /dev/null
      then
        echo "Cannot find script $1"
        usage_error=1
      fi
      $setup_command = $1
      ;;
		-e|--edit-fstab)
			shift
			edit_fstab_name=$1
			;;
		-f|--force-initialize)
			force_initialize=1
			;;
		-f2)
			force_initialize=1
			force_2_parts=1
			;;
    -2)
			force_2_parts=1
			;;
		-x)
			set -x
			;;
		-a|--all-sync)
			all_sync=1
			;;
		-m|--mountdir)
			shift
			mount_ok=0
			for ((p = 1; p <= n_src_parts; p++))
			do
				if ((!src_exists[p]))
				then
					continue
				fi
				if ((!custom_sync)) && ((p != root_part_num))
				then
					src_sync_part[p]=0
				fi
				if [ "${src_mounted_dir[p]}" == "$1" ]
				then
					src_sync_part[p]=1
					mount_ok=1
				fi
			done
			if ((!mount_ok))
			then
				echo "Asking to clone directory \"$1\", but it is not mounted."
				usage_error=1
			fi
			custom_sync=1
			;;
    -y|--syncdir)
			shift
      if [ "$rsync_extra_dirs" == "" ]
			then
				rsync_extra_dirs="$1"
			else
				rsync_extra_dirs="$rsync_extra_dirs, $1"
			fi
			;;
		-L|--label_partitions)
			shift
			ext_label=$1
			;;
		-l|--leave-sd-usb-boot)
			leave_sd_usb_boot=1
			;;
		-F|--Force-sync)
			force_sync=1
			;;
		--convert-fstab-to-partuuid)
			convert_to_partuuid=1
			;;
		-V|--version)
			echo $PGM Version: $version
			exit 0
			;;
		-h|--help)
			usage
			;;
		*)
			if [ "$dst_part" != "" ]
			then
				echo "Bad args"
				usage
			fi
#      echo $1
			dst_part=$1
			dir=`expr substr $dst_part 1 5`
			if [ "$dir" == "/dev/" ]
			then
				dst_part=${dst_disk#/dev/}
			fi
			;;
	esac
	shift
done


#########################################################
# Starts determining source and target devices/partitions
#########################################################

if [ "$dst_part" = "" ]
then
	echo "No destination disk given."
	usage
fi

chk_disk=`cat /proc/partitions | grep -m 1 $dst_part`

if [ "$chk_disk" == "" ]
then
	echo $"
  Cannot find '$dst_part' in the partition table.  The partition table is:"
	cat /proc/partitions
	exit 1
fi

dst_part_base=$dst_part

############################################################
# Verifica que el destino sea un disco y no una particion
# para ello se fija si termina en digito
############################################################
if [[ ! ${chk_disk: -1} =~ ^[0-9]$ ]]
then
  qecho $"
Target partition $dst_part does not ends with a digit so may be a device.
$PGM requires partition names like 'sda1' and not device names like 'sda'."
  qecho ""
  exit 0
fi

src_root=${src_root_dev#/dev/}
if [ "$src_root" == "$dst_part" ]
then
	echo "Destination partition $dst_part is the booted root.  Cannot clone!"
	exit 1
fi

src_boot=${src_boot_dev#/dev/}
if [ "$src_boot" == "$dst_part" ]
then
	echo "Destination partition $dst_part is the booted boot.  Cannot clone!"
	exit 1
fi


############################################################
# Gets info about destination partition
############################################################

print_partitions

dst_device="/dev/"$dst_part
dest_disk=${dst_part:: -1}
dst_part_num="${dst_part: -1}"

readable "${src_size_sectors[$boot_part_num]}" "512" tmp
printf -v boot_size_readable "%7s" $tmp

readable "${src_used_sectors[$boot_part_num]}" "512" tmp
printf -v boot_used_readable "%7s" $tmp



printf "\n"
printf "Part      ## Dev     Size   Used \n"
printf "=======================================\n"
printf "Boot      %2s %8s  %7s %7s\n"  "$boot_part_num" "$src_boot_dev" "$boot_size_readable" "$boot_used_readable"
printf "Source    %2s %8s    \n"  "$root_part_num" "$src_root_dev"
printf "Dest      %2s %8s\n"      "$dst_part_num"  "$dst_device"

printf "\n"


if [ ! -d $snap ]
then
	mkdir $snap
fi

# Do not include a dhpys swapfile in rsync.  It regenerates at boot.
#
if [ -f /etc/dphys-swapfile ]
then
	swapfile=`cat /etc/dphys-swapfile | grep ^CONF_SWAPFILE | cut -f 2 -d=`
	if [ "$swapfile" = "" ]
	then
		swapfile=/var/swap
	fi
	exclude_swapfile="--exclude $swapfile"
fi


####################################################################
# Checks that dest partition has the needed size
####################################################################
if ((${src_size_sectors[$dst_part_num]} < ${src_used_sectors[$root_part_num]}))
then
  readable ${src_used_sectors[$root_part_num]} "512" src_used_readable
	readable ${src_size_sectors[$dst_part_num]}  "512" dst_size_readable

  qprintf "%-12s : %s\n\n" "** FATAL **" \
  "Partition $root_part_num: source used ($src_used_readable) > destination space ($dst_size_readable)"
  exit 0
fi

confirm "Ok to proceed with the clone?" "abort"
start_time=`date '+%H:%M:%S'`
start_sec=$(date '+%s')

sync
qprintf "\nSyncing file systems (can take a long time)\n"


####################################################################
# 1- Montar la dest part en $snap
####################################################################
echo mount_partition $dst_root_dev $snap ""
unmount_list="$snap"

####################################################################
# 2- Sync root
####################################################################
echo rsync_file_system "//" "$snap" "with-root-excludes"

#set -x
####################################################################
# 3- Modify next boot part
####################################################################
if (( 1 == 0 ))
then
      if grep -q "PARTUUID" $cmdline_txt
      then
        qecho "Editing $cmdline_txt PARTUUID to use $dst_disk_ID"
        sed -i "s/\(root=PARTUUID=\)\(\S\+\)\(\s\+\)/\1${dst_disk_ID}-02\3/" "$cmdline_txt"
      elif [ "$edit_fstab_name" != "" ] && grep -q ${src_part_base} $cmdline_txt
      then
        qecho "Editing $cmdline_txt references from $src_part_base to $edit_fstab_name"
        sed -i "s/${src_part_base}/$edit_fstab_name/" "$cmdline_txt"
      fi

      if ((leave_sd_usb_boot && SD_slot_boot))
      then
        qecho "Copying USB cmdline.txt to SD card to set up USB boot."
        cp /boot/cmdline.txt /boot/cmdline.boot
        cp $cmdline_txt /boot/cmdline.txt
      fi
#fi
      #if grep -q $src_disk_ID $fstab
      if grep -q "PARTUUID" $cmdline_txt
      then
        qecho "Editing $fstab PARTUUID to use $dst_disk_ID"
        #	sed -i "s/${src_disk_ID}/${dst_disk_ID}/g" "$fstab"
        sed -i "s/\(PARTUUID=\)\s*\(\S\+\)\(\s\+\/boot\s\+\)/\1${dst_disk_ID}-01\3/" "$fstab"
        sed -i "s/\(PARTUUID=\)\s*\(\S\+\)\(\s\+\/\s\+\)/\1${dst_disk_ID}-02\3/" "$fstab"

        # ACA HAY QUE COMENTAR LAS ENTRADAS DE FSTAB QUE APUNTAN A PARTICIONES QUE NO SE
        # VAN A MONTAR EN UN BOOT SD-SD

        # Todas las entradas que contenga UUID, y que no sean '/' o '/boot' (no es muy
        # correcto, deberia detectar que no mapean a SD)

      elif [ "$edit_fstab_name" != "" ] && grep -q ${src_part_base} $fstab
      then
        qecho "Editing $fstab references from $src_part_base to $edit_fstab_name"
        sed -i "s/${src_part_base}/${edit_fstab_name}/" "$fstab"
      fi
fi


####################################################################
# CLEANUP
####################################################################
echo rm -f $snap/etc/udev/rules.d/70-persistent-net.rules

if [ "$setup_args" != "" ]
then
	qprintf "\nRunning setup script: $setup_command $setup_args\n"
	$setup_command $setup_args
fi


####################################################################
# Generate LOg entries
####################################################################
date=`date '+%F %H:%M'`
echo "$date  $HOSTNAME $PGM : snapshot to $dst_part ($dst_root_vol_name)" >> $snap_log
echo "$date  $HOSTNAME $PGM : snapshot to $dst_part ($dst_root_vol_name)" >> ${snap}${snap_log}

stop_sec=$(date '+%s')
clone_sec=$((stop_sec - start_sec))
stop_time=`date '+%H:%M:%S'`

qecho "
============================================================="
qecho "Done with snapshot to /dev/$dst_part"
qprintf "   Start - %s    End - %s    Elapsed Time - %d:%02d\n" \
		"$start_time" "$stop_time" "$((clone_sec / 60))" "$((clone_sec % 60))"


####################################################################
# Pause before unmounting partitions
####################################################################
if ((!unattended))
then
	echo -n $"
Cloned partitions are mounted on $snap for inspection or customizing.

Hit Enter when ready to unmount the /dev/$dst_part partition..."

	read resp
fi

## --dry-run
echo unmount_list "$unmount_list"
qprintf "=============================================================\n\n"

exit 0
